<!-- Musical Circles -->
<!DOCTYPE html>
<html>
<head>
	<title>Chordwheel</title>
	<link rel="icon" href='favicon.ico'>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

	<style>
		body { 
			background-color: hsl(0, 0%, 0%); 
			color: gray;
			text-align: center
		}
		.option {
			display: inline-block;
			padding: 30px;
			width: 250px;
			vertical-align:top
		}
		select {
            color: red;
			background-color: black;
        }
		button {
			background-color: black;
			color: white;
			margin: 3px;
		}
		#options {
			display: none;
		}
	</style>
</head>
<body>
	<br>
	<!-- <h3>C H O R D W H E E L</h3> -->
	<div id="main">
		<canvas id="canvas" width="600px" height="600px" style="margin: auto; display: block;"></canvas>
	</div>
	<div id="optionsButton">
		<h2>. . .</h2>
	</div>
	<div id ="options">
		<br><br>
		<div class="option">
			Visuals:
			<br>
			<button id="colorModeButton">
				Color Mode: Fifths
			</button><br>
			<button id="noteModeButton">
				Note Mode: Chromatic
			</button><br>
			<button id="noteModeButton">
				Interval Colors: White -> Red
			</button>
		</div>
		<div class="option">
			<h3>Build a Chord</h3>
			Root:
			<div>
				<input type="range" min="0" max="11" class="slider" id="rootSlider">
			</div>
			Chord Type:
			<br>
			<div id=chordButtons></div>
		</div>
		<div class="option">
			Rotate with left/right keys
			<select name="rotationAmount" id="rotationAmount">
				<option value="1">1</option>
				<option value="2">2</option>
				<option value="3">3</option>
				<option value="4">4</option>
			</select><br>
		</div>
		
		<div class="option">
			Enter chord progression (cycle with spacebar)
			<br>
			<input id="chordProgression">
		</div>
	</div>
<script>


let colorModeFifths = true
let noteModeFifths = false

// All options are under single '...'

// OPTIONS
// Color mode: true vs fudged
// chromatic vs fifths (notes/color)
// Select root / chord types

// Left / right interval
// Flip

// Enter chord progression

// TODO:
// Add root / chord type buttons - shows up after you hit a note?
// Add fifth option (vs chromatic)
//
// Shade in triangles

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const DOT_SIZE = 23
const RADIUS = 175
const CENTER = [300, 300]
const SPACE_CODE = 32
const TET = 12
const noteNames =    ['A', 'Bb', 'B', 'C', "C#", 'D', 'Eb','E', 'F', "F#", 'G', 'Ab']
const displayNotes = ['A', 'B♭', 'B', 'C', 'C♯', 'D', 'E♭','E', 'F', 'F♯', 'G', 'A♭']
const altNoteNames = ['A', 'B',  'C', 'D', 'E',  'F', 'G', 'H', 'I', 'J',  'K', 'L']

//let clickable = true
let currentChord = -1;

const godOnlyKnows = "A E A E A E F#m7 E F# G D Bm6 F#m F#m7 F#m6 E Ebº7 E C#m6 A E F#m E F# G"

// embarrassing
// const godOnlyKnows = "F# Ebm Abm Bbm A7 D Cº7 C#7 F# Ebm Abm Bbm A7 D Cø7 C#7 F#"

let intervalColors = [
	[
		'red',
		'blue',
		'purple',
		'green',
		'orange',
		'yellow'],
	[
		"red", // red
		`hsl(25, 100%, 50%)`, // orange
		`hsl(40, 100%, 50%)`, // orange-yellow
		`hsl(50, 100%, 50%)`, // yellow
		`hsl(60, 100%, 75%)`, // light yellow
		"white"]
]

let noteColors = [
	`hsl(0, 100%, 50%)`, // red
	`hsl(20, 100%, 50%)`, // orange-red
	`hsl(40, 100%, 50%)`, // orange-yellow
	`hsl(60, 100%, 50%)`, // yellow
	`hsl(90, 100%, 50%)`, // yellow-green
	`hsl(135, 100%, 35%)`, // green
	`hsl(165, 100%, 35%)`, // green-blue
	`hsl(205, 100%, 40%)`, // blue-green
	`hsl(240, 100%, 50%)`, // blue
	`hsl(265, 100%, 50%)`, // blue-purple
	`hsl(285, 100%, 50%)`, // purple
	`hsl(330, 100%, 50%)`, // purple-red
]

const chords = {
	//"5":   [[0, 7],				"Five"],
	"" :   [[0, 4, 7], 			"Major"	],						//Jubilant
	"m":   [[0, 3, 7],			"Minor"	],						//Tragic 	//-
	"∫":   [[0, 5, 7],			"Suspended"],					
	"º":   [[0, 3, 6],			"Diminished"],					
	"+":   [[0, 4, 8],			"Augmented"],					
	"b5":  [[0, 4, 6],			"Flat Five"],					//Stunted
	"7":   [[0, 4, 7, 10],		"Dominant Seven"],				//Dominant
	"m7":  [[0, 3, 7, 10],		"Minor Seven / Six"],			//Submissive
	"∆7":  [[0, 4, 7, 11],		"Major Seven"],					//Placid		//maj7
	"m6":  [[0, 3, 7, 9],		"Minor Sixth"],				
	"m9":  [[0, 2, 3, 7],		"Minor Nine"],				
	"∫7":  [[0, 5, 7, 9],		"Suspended Seven"],				//Illusory
	"∫∆7": [[0, 5, 7, 10],		"Suspended Major Seven"],		//Ephemeral
	"º7":  [[0, 3, 6, 9],		"Diminished Seventh"],			
	"µ":   [[0, 2, 4, 7],		"Mu"],							//Thickened		//add9 //add2 //mu
	"9":   [[0, 2, 4, 7, 10],  	"Dominant Nine"],			
	"∆9":  [[0, 2, 4, 7, 11],  	"Major Nine"],				
	"∫9":  [[0, 2, 5, 7, 10], 	"Suspended Nine"],			
	"∫∆9": [[0, 2, 5, 7, 11],	"Suspended Major Nine"],		//Ephemeral
}

let audios = []
let noteState = []
let clickAudio = new Audio()
clickAudio.src = "click.wav"
clickAudio.volume = .15

for (let i = 0; i < TET; i++) {
	let audio = new Audio()
	audio.loop = true
	audio.volume = .3
	audio.src = "notes/" + noteNames[i].replace("#", "x") + ".mp3"
	audios.push(audio)
	noteState[i] = false
}

let optionsHidden = true
let optionsDiv = document.getElementById("options")
document.getElementById("optionsButton").onclick = function() {
	clickAudio.play()
	optionsHidden = !optionsHidden
	optionsDiv.style.display = optionsHidden ? "none" : "inline-block"	
}

let colorModeButton = document.getElementById("colorModeButton")
colorModeButton.onclick = function() {
	colorModeFifths = !colorModeFifths
	colorModeButton.innerHTML = colorModeFifths ? "Color Mode: Fifths" : "Color Mode: Chromatic"	
	clickAudio.play()
	refresh()
}

let noteModeButton = document.getElementById("noteModeButton")
noteModeButton.onclick = function() {
	noteModeFifths = !noteModeFifths
	noteModeButton.innerHTML = noteModeFifths ? "Note Mode: Fifths" : "Note Mode: Chromatic"
	clickAudio.play()
	refresh()
}

$("#rootSlider").value = 0
$("#rootSlider").css('accentColor', "red")
$(document).on('input', '[type="range"]',
  function() {
	let color = noteToColor($(this).val())
    $(this).css('accentColor', color)
	$('.chordButton').css('borderColor', color)
});

for (chord in chords) {
	let newButton = document.createElement("button")
	newButton.className = "chordButton"
	newButton.innerHTML = chord == "" ? "(major)" : chord
	newButton.onclick = function(e) {
		let chord = e.target.innerHTML == "(major)" ? "" : e.target.innerHTML
		setChord(transposeChord(chords[chord][0], rootSlider.value))
		refresh()
		updateAllAudios()
	}
	document.getElementById("chordButtons").appendChild(newButton)
}


// TODO: clusters of 3 shade, overlap when clusters of 4

// Augmented Diminished Suspended Dominant
// Pensive
// Placid 
// Tranquil
// Serene
// Neutral
// Nostalgic
// Disfigured
// Embellished
// Illusory
// Neutral
// Ephemeral
// Conflicted
// Contrived
// Elevated 
// Dynamic
// Extruded 
// Disfigured
// Contorted 
// Embellished 
// Embodied
// Reflected / Reflective
// Chilled
// Placid
// Elevated
// Iconic 
// Pensive
// Galvanized
// Submissive
// Turgid
// Strengthened
// Depressed
// Radical
// Entrenched	
// Distended
// Meloncholic
// Pitiful
// Tragic
// Richened


/////////////////////
// CONTROL
/////////////////////
document.body.onkeyup = function(e) {
	if (e.keyCode == SPACE_CODE) {
    	nextChord()
    } else if (e.keyCode == 37) {
		rotateLeft()
	} else if (e.keyCode == 39) {
		rotateRight()
	} else if (e.keyCode == 38) {
		doubleUp()
	} else if (e.keyCode == 40) {
		doubleDown()
	}
}

canvas.addEventListener('mousedown', function(e) {
    buttonClick(canvas, e)
})

function buttonClick(canvas, event) {
    const rect = canvas.getBoundingClientRect()
	let note = checkClick([event.clientX - rect.left, event.clientY - rect.top])
    if (note != -1) {
		noteState[note] = !noteState[note]
		updateAudio(audios[note], noteState[note])
		refresh()
	}
}

function checkClick(point) {
	for (let i = 0; i < TET; i++) {
		if (distanceToPoint(point, getPointOnCircle(CENTER, i % TET, RADIUS)) < DOT_SIZE) {
			return i
		}
	}
	return -1
}

function distanceToPoint(p1, p2) {
	let dx = p1[0] - p2[0];
	let dy = p1[1] - p2[1];
	return Math.sqrt(dx * dx + dy * dy);
}

//////////// Sound
function updateAllAudios() {
	for (let i = 0; i < TET; i++) {
		updateAudio(audios[i], noteState[i])
	}
}

function updateAudio(audio, isOn) {
	if (isOn != audio.paused) {
		return // no change needed
	}
	if (isOn) {
		audio.currenttime = 0;
		audio.play()
	} else {
		audio.pause()
		audio.currenttime = 0;
	}
}

function refresh(first = false) {
	if (!first) {
		clickAudio.currentTime = 0
		clickAudio.play()
	}
	ctx.clearRect(0, 0, 1000, 1000);
	drawChord()
	drawColorWheel()
}

function drawColorWheel() {
	for (i = 0; i < TET; i++) {
		let isFilled = noteState[i]
		drawDot(
			getPointOnCircle(CENTER, i, RADIUS), 
			noteToColor(i),
			displayNotes[i], 
			isFilled); //notes[(i+117) % notes.length]
	}
}

function getPointOnCircle(center, n, radius) {
	if (noteModeFifths) {
		n = (n * 7) % 12
	}
	n += 3
	return [center[0] + Math.cos(2 * Math.PI * n / TET) * radius, 
		center[1] + Math.sin(2 * Math.PI * n / TET) * radius]
}

function noteToColor(i, trueColor = false) {
	if ((colorModeFifths && !noteModeFifths) || (!colorModeFifths && noteModeFifths)) {
		i = (i * 7) % 12
	}
	if (trueColor) {
		let color = 360 * i / TET
		return `hsl(${color}, 100%, 50%)`
	} else {
		return noteColors[i]
	}
}

function drawDot(center, color, text, filled) {
	ctx.lineWidth = 2
	ctx.beginPath()
	ctx.arc(center[0], center[1], DOT_SIZE, 0, 2 * Math.PI)
	if (filled) {
		ctx.fillStyle = color
		ctx.fill()
	} else {
		ctx.strokeStyle = color
		ctx.stroke()
	}
	//ctx.fillStyle = `black`
	//ctx.fillText(text, center[0]-8, center[1]+8)
}

function drawChord() {
	let chord = []
	for (let i = 0; i < TET; i++) {
		if (noteState[i]) {
			chord.push(i)
		}
	}
	let numIntervals = 0
	let intervalTotal = 0
	for (i = 0; i < chord.length; i++) {
		let n1 = chord[i]
		p1 = getPointOnCircle(CENTER, n1, RADIUS)
		for (let j = i + 1; j < chord.length; j++) {
			let n2 = chord[j]
			let p2 = getPointOnCircle(CENTER, n2, RADIUS)
			let interval = Math.min(Math.abs(n1 - n2), 12 - Math.abs(n1 - n2)) % 6
			intervalTotal += interval
			numIntervals++
			// intervals are measured from dissonant (0, tritone) to consonant (5, fifth)
			drawLine(p1, p2, interval)
		}
	}
	// TODO: some weight for 'variance'?
	// if 3 notes same - 0 
	// if 3 notes diff - 1

	if (numIntervals > 0) {
		//let consonanceScore = 100.0 * (intervalTotal / (5 * numIntervals))
		//console.log(consonanceScore + "%")
	}
}

function drawLine(pos1, pos2, interval) {
	ctx.lineWidth = 3
	if (interval == 5 || interval == 0) {
		ctx.lineWidth = 3
	}
	//ctx.strokeStyle = `hsl(0, 100%, ${50 + interval * 10}%)` // white -> red
	//ctx.strokeStyle = `hsl(${interval * (60 / 5)}, 100%, 50%)` // yellow -> red
	ctx.strokeStyle = intervalColors[1][interval]
	//ctx.strokeStyle = "white"
	ctx.beginPath()
	ctx.moveTo(pos1[0], pos1[1])
	ctx.lineTo(pos2[0], pos2[1])
	ctx.stroke()
}


function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	}
}

function rotateLeft() {
	noteState.push(noteState[0])
	noteState.splice(0, 1)
	updateAllAudios()
	refresh()
}

function rotateRight() {
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	updateAllAudios()	
	refresh()
}

function doubleUp() {
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	updateAllAudios()	
	refresh()
}

function doubleDown() {
	noteState.push(noteState[0])
	noteState.push(noteState[1])
	noteState.splice(0, 2)
	updateAllAudios()	
	refresh()
}

function flip() {
	noteState = noteState.reverse()
	updateAllAudios()	
	refresh()
}

let chordProgression = document.getElementById("chordProgression")
function nextChord() {
	let customChords = parseChords(chordProgression.value)
	if (customChords.length == 0) {
		return
	}
	currentChord += 1
	if (currentChord >= customChords.length) {
		currentChord = 0
	}
	ctx.fillStyle = "white"
	ctx.font = "20px Arial";
	//ctx.fillText(Object.keys(chords)[currentChord], 10, 50);
	//ctx.fillText("hi", 400, 400)
	setChord(customChords[currentChord])
	refresh()
	updateAllAudios()
}

function parseChords(chordString) {
	let splitChords = chordString.split(" ")
	let result = []
	for (let i = 0; i < splitChords.length; i++) {
		try {
			result.push(parseChord(splitChords[i]))
		} catch { }
	}
	return result
}

function parseChord(chordName) {
	var root
	var chordType
	if (chordName.length == 1) {
		root = chordName[0]
		chordType = ""
	} else if (chordName[1] == "#" || chordName[1] == "b") {
		root = chordName.substring(0, 2)
		chordType = chordName.substring(2)
	} else {
		root = chordName.substring(0, 1)
		chordType = chordName.substring(1)
	}
	let rootIndex = noteNames.indexOf(root)
	let chordNotes = chords[chordType];
	return transposeChord(chords[chordType][0], rootIndex)
}

function transposeChord(chord, interval) {
	let transposedChord = []
	for (let i = 0; i < chord.length; i++) {
		transposedChord.push((interval + chord[i]) % 12)
	}
	return transposedChord	
}

function setChord(chord) {
	for (i = 0; i < TET; i++) {
		noteState[i] = 0
	}
	for (i = 0; i < chord.length; i++) {
		noteState[chord[i]] = 1
	}
}

refresh(true)

</script>
</body>
</html>