<!-- Musical Circles -->
<!DOCTYPE html>
<html>
<head>
	<title>Chordwheel</title>
	<link rel="icon" href='favicon.ico'>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<style>
		body { 
			background-color: hsl(0, 0%, 0%); 
			color: gray;
			text-align: center
		}
		.option {
			display: inline-block;
			padding: 30px;
			width: 300px;
			vertical-align:top
		}
		select {
            color: red;
			background-color: black;
        }
		button {
			background-color: black;
			color: white;
			margin: 3px;
		}
		#options {
			display: none;
		}

		#chordProgression {
			width: 250px;
		}
	</style>
</head>
<body>
	<br>
	<!-- <h3>C H O R D W H E E L</h3> -->
	<div id="main">
		<canvas id="canvas" width="600px" height="600px" style="margin: auto; display: block;"></canvas>
	</div>
	<div id="optionsButton">
		<h2>. . .</h2>
	</div>
	<div id ="options">
		<div class="option">
			<h3>Visuals</h3>
			<div>
				<input type="checkbox" id="showNotes"/>
				<label for="showNotes">Show Notes</label>
			</div>
			<button id="colorModeButton">
				Color Mode: Chromatic
			</button><br>
			<button id="noteModeButton">
				Note Mode: Chromatic
			</button><br>
			<button id="intervalColorButton">
				Interval Colors: White/Yellow/Red
			</button>
		</div>
		<div class="option">
			<h3>Set Chord</h3>
			<div id="rooTitle">Root:</div>
			<div>
				<input type="range" min="0" max="11" class="slider" id="rootSlider">
			</div>
			Chord Type:
			<br>
			<div id=chordButtons3></div>
			<div id=chordButtons4></div>
			<div id=chordButtons5></div>
		</div>
		<!-- <div class="option">
			Rotate with left/right keys
			<select name="rotationAmount" id="rotationAmount">
				<option value="1">1</option>
				<option value="2">2</option>
				<option value="3">3</option>
				<option value="4">4</option>
			</select><br>
		</div> -->
		
		<div class="option">
			<h3>Custom Chord Progression</h3>
			<input id="chordProgression">
			<br><br>
			(once entered, cycle with spacebar)
		</div>
	</div>
<script>


let colorModeFifths = false
let noteModeFifths = false

// All options are under single '...'

// OPTIONS
// Color mode: true vs fudged
// chromatic vs fifths (notes/color)
// Select root / chord types

// Left / right interval
// Flip

// Enter chord progression

// TODO:
// Add root / chord type buttons - shows up after you hit a note?
// Add fifth option (vs chromatic)
//
// Shade in triangles

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const DOT_SIZE = 23
const RADIUS = 175
const CENTER = [300, 300]
const SPACE_CODE = 32
const TET = 12
const noteNames =    ['A', 'Bb', 'B', 'C', "C#", 'D', 'Eb','E', 'F', "F#", 'G', 'Ab']
const displayNotes = ['A', 'B♭', 'B', 'C', 'C♯', 'D', 'E♭','E', 'F', 'F♯', 'G', 'A♭']
const altNoteNames = ['A', 'B',  'C', 'D', 'E',  'F', 'G', 'H', 'I', 'J',  'K', 'L']

let currentChord = -1;

let intervalColors = [
	[
		"red", // red
		`hsl(25, 100%, 50%)`, // orange
		`hsl(40, 100%, 50%)`, // orange-yellow
		`hsl(50, 100%, 50%)`, // yellow
		`hsl(60, 100%, 75%)`, // light yellow
		"white"
	],[
		'red',
		'blue',
		'purple',
		'green',
		'orange',
		'yellow'
	]
]

let noteColors = [
	`hsl(0, 100%, 50%)`, // red
	`hsl(20, 100%, 50%)`, // orange-red
	`hsl(40, 100%, 50%)`, // orange-yellow
	`hsl(60, 100%, 50%)`, // yellow
	`hsl(90, 100%, 50%)`, // yellow-green
	`hsl(135, 100%, 35%)`, // green
	`hsl(165, 100%, 35%)`, // green-blue
	`hsl(205, 100%, 40%)`, // blue-green
	`hsl(240, 100%, 50%)`, // blue
	`hsl(265, 100%, 50%)`, // blue-purple
	`hsl(285, 100%, 50%)`, // purple
	`hsl(330, 100%, 50%)`, // purple-red
]

const chords = {
	//"5": [[0, 7],				"Five"],
	"" :   [[0, 4, 7], 			"Major"	],						//Jubilant
	"m":   [[0, 3, 7],			"Minor"	],						//Tragic 	//-
	"∫":   [[0, 5, 7],			"Suspended"],					
	"º":   [[0, 3, 6],			"Diminished"],					
	"+":   [[0, 4, 8],			"Augmented"],					
	"b5":  [[0, 4, 6],			"Flat Five"],					//Stunted
	"7":   [[0, 4, 7, 10],		"Dominant Seven"],				//Dominant
	"m7":  [[0, 3, 7, 10],		"Minor Seven / Six"],			//Submissive
	"∆7":  [[0, 4, 7, 11],		"Major Seven"],					//Placid		//maj7
	"m6":  [[0, 3, 7, 9],		"Minor Sixth"],				
	"m9":  [[0, 2, 3, 7],		"Minor Nine"],				
	"∫7":  [[0, 5, 7, 10],		"Suspended Seven"],				//Illusory
	"∫∆7": [[0, 5, 7, 11],		"Suspended Major Seven"],		//Ephemeral
	"º7":  [[0, 3, 6, 9],		"Diminished Seventh"],			
	"µ":   [[0, 2, 4, 7],		"Mu"],							//Thickened		//add9 //add2 //mu
	"9":   [[0, 2, 4, 7, 10],  	"Dominant Nine"],			
	"∆9":  [[0, 2, 4, 7, 11],  	"Major Nine"],				
	"∫9":  [[0, 2, 5, 7, 10], 	"Suspended Nine"],			
	"∫∆9": [[0, 2, 5, 7, 11],	"Suspended Major Nine"],		//Ephemeral
}

let audios = []
let noteState = []
let clickAudio = new Audio()
clickAudio.src = "click.wav"
clickAudio.volume = .15

for (let i = 0; i < TET; i++) {
	let audio = new Audio()
	audio.loop = true
	audio.volume = .3
	audio.src = "notes/" + noteNames[i].replace("#", "x") + ".mp3"
	audios.push(audio)
	noteState[i] = false
}

let showNotes = false
document.getElementById("showNotes").onclick = function() {
	showNotes = !showNotes
	refresh()
}

let optionsHidden = true
let optionsDiv = document.getElementById("options")
document.getElementById("optionsButton").onclick = function() {
	clickAudio.play()
	optionsHidden = !optionsHidden
	optionsDiv.style.display = optionsHidden ? "none" : "inline-block"	
}

let colorModeButton = document.getElementById("colorModeButton")
colorModeButton.onclick = function() {
	colorModeFifths = !colorModeFifths
	colorModeButton.innerHTML = colorModeFifths ? "Color Mode: Fifths" : "Color Mode: Chromatic"	
	clickAudio.play()
	refresh()
}

let noteModeButton = document.getElementById("noteModeButton")
noteModeButton.onclick = function() {
	noteModeFifths = !noteModeFifths
	noteModeButton.innerHTML = noteModeFifths ? "Note Mode: Fifths" : "Note Mode: Chromatic"
	clickAudio.play()
	refresh()
}


let intervalColorMode = 0
let intervalColorButton = document.getElementById("intervalColorButton")
intervalColorButton.onclick = function() {
	intervalColorMode = (intervalColorMode + 1) % 3
	if (intervalColorMode == 0) {
		intervalColorButton.innerHTML = "Interval Colors: White/Yellow/Red"
	} else if (intervalColorMode == 1) {
		intervalColorButton.innerHTML = "Interval Colors: Rainbow"
	} else if (intervalColorMode == 2) {
		intervalColorButton.innerHTML = "Interval Colors: White"
	}
	clickAudio.play()
	refresh()
}

$("#rootSlider").value = 0
$("#rootSlider").css('accentColor', "red")
$(document).on('input', '[type="range"]',
  function() {
	let color = noteToColor($(this).val())
    $(this).css('accentColor', color)
	$('.chordButton').css('borderColor', color)
});

for (chord in chords) {
	let newButton = document.createElement("button")
	newButton.className = "chordButton"
	newButton.innerHTML = chord == "" ? "(major)" : chord
	newButton.onclick = function(e) {
		clickAudio.play()
		let chord = e.target.innerHTML == "(major)" ? "" : e.target.innerHTML
		let transposedChord = transposeChord(chords[chord][0], parseInt(rootSlider.value))
		setChord(transposedChord)
		refresh()
		updateAllAudios()
	}
	document.getElementById("chordButtons" + chords[chord][0].length).appendChild(newButton)
}


// TODO: clusters of 3 shade, overlap when clusters of 4

// Augmented Diminished Suspended Dominant


// Pitiful
// Tragic

// Disfigured
// Conflicted
// Contrived

// Contorted 

// Pensive
// Placid 
// Tranquil
// Serene
// Illusory
// Neutral
// Nostalgic
// Neutral
// Ephemeral
// Elevated 
// Dynamic
// Extruded 
// Embellished 
// Embodied
// Reflected / Reflective
// Chilled
// Iconic 
// Galvanized
// Submissive
// Turgid
// Strengthened
// Depressed
// Radical
// Entrenched	
// Distended
// Meloncholic
// Richened
// Inflated


/////////////////////
// CONTROL
/////////////////////
document.body.onkeyup = function(e) {
	if (document.activeElement.id == "chordProgression") {
		return
	}
	if (e.keyCode == SPACE_CODE) {
    	nextChord()
    } else if (e.keyCode == 37) {
		rotateLeft()
	} else if (e.keyCode == 39) {
		rotateRight()
	} else if (e.keyCode == 38) {
		doubleUp()
	} else if (e.keyCode == 40) {
		doubleDown()
	}
}

canvas.addEventListener('mousedown', function(e) {
    buttonClick(canvas, e)
})

function buttonClick(canvas, event) {
    const rect = canvas.getBoundingClientRect()
	let note = checkClick([event.clientX - rect.left, event.clientY - rect.top])
    if (note != -1) {
		noteState[note] = !noteState[note]
		updateAudio(audios[note], noteState[note])
		refresh()
	}
}

function checkClick(point) {
	for (let i = 0; i < TET; i++) {
		if (distanceToPoint(point, getPointOnCircle(CENTER, i % TET, RADIUS)) < DOT_SIZE) {
			return i
		}
	}
	return -1
}

function distanceToPoint(p1, p2) {
	let dx = p1[0] - p2[0];
	let dy = p1[1] - p2[1];
	return Math.sqrt(dx * dx + dy * dy);
}

//////////// Sound
function updateAllAudios() {
	for (let i = 0; i < TET; i++) {
		updateAudio(audios[i], noteState[i])
	}
}

function updateAudio(audio, isOn) {
	if (isOn != audio.paused) {
		return // no change needed
	}
	if (isOn) {
		audio.currenttime = 0;
		audio.play()
	} else {
		audio.pause()
		audio.currenttime = 0;
	}
}

function refresh(first = false) {
	if (!first) {
		clickAudio.currentTime = 0
		clickAudio.play()
	}
	ctx.clearRect(0, 0, 1000, 1000);
	drawChord()
	drawColorWheel()
}

function drawColorWheel() {
	for (i = 0; i < TET; i++) {
		let isFilled = noteState[i]
		drawDot(
			getPointOnCircle(CENTER, i, RADIUS), 
			noteToColor(i),
			isFilled,
			displayNotes[i]); //notes[(i+117) % notes.length]
	}
}

function getPointOnCircle(center, n, radius) {
	if (noteModeFifths) {
		n = (n * 7) % TET
	}
	n += 3
	return [center[0] + Math.cos(2 * Math.PI * n / TET) * radius, 
		center[1] + Math.sin(2 * Math.PI * n / TET) * radius]
}

function noteToColor(i, trueColor = false) {
	if ((colorModeFifths && !noteModeFifths) || (!colorModeFifths && noteModeFifths)) {
		i = (i * 7) % TET
	}
	if (trueColor) {
		let color = 360 * i / TET
		return `hsl(${color}, 100%, 50%)`
	} else {
		return noteColors[i]
	}
}

function drawDot(center, color, filled, text) {
	ctx.lineWidth = 2
	ctx.beginPath()
	ctx.arc(center[0], center[1], DOT_SIZE, 0, 2 * Math.PI)
	if (filled) {
		ctx.fillStyle = color
		ctx.fill()
	} else {
		ctx.strokeStyle = color
		ctx.stroke()
	}
	if (showNotes) {
		ctx.fillStyle = filled ? "black" : "white"
		ctx.fillText(text, center[0]-3, center[1]+3)
	}
}

function drawChord() {
	let chord = []
	for (let i = 0; i < TET; i++) {
		if (noteState[i]) {
			chord.push(i)
		}
	}
	let numIntervals = 0
	let intervalTotal = 0
	for (i = 0; i < chord.length; i++) {
		let n1 = chord[i]
		p1 = getPointOnCircle(CENTER, n1, RADIUS)
		for (let j = i + 1; j < chord.length; j++) {
			let n2 = chord[j]
			let p2 = getPointOnCircle(CENTER, n2, RADIUS)
			let interval = Math.min(Math.abs(n1 - n2), TET - Math.abs(n1 - n2)) % 6
			intervalTotal += interval
			numIntervals++
			// intervals are measured from dissonant (0, tritone) to consonant (5, fifth)
			drawLine(p1, p2, interval)
		}
	}
	// TODO: some weight for 'variance'?
	// if 3 notes same - 0 
	// if 3 notes diff - 1

	if (numIntervals > 0) {
		//let consonanceScore = 100.0 * (intervalTotal / (5 * numIntervals))
		//console.log(consonanceScore + "%")
	}
}

function drawLine(pos1, pos2, interval) {
	ctx.lineWidth = 3
	if (interval == 5 || interval == 0) {
		ctx.lineWidth = 3
	}
	//ctx.strokeStyle = `hsl(0, 100%, ${50 + interval * 10}%)` // white -> red
	//ctx.strokeStyle = `hsl(${interval * (60 / 5)}, 100%, 50%)` // yellow -> red
	if (intervalColorMode == 2) {
		ctx.strokeStyle = "white"
	} else {
		ctx.strokeStyle = intervalColors[intervalColorMode][interval]
	}
	//ctx.strokeStyle = "white"
	ctx.beginPath()
	ctx.moveTo(pos1[0], pos1[1])
	ctx.lineTo(pos2[0], pos2[1])
	ctx.stroke()
}


function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	}
}

function rotateLeft() {
	noteState.push(noteState[0])
	noteState.splice(0, 1)
	updateAllAudios()
	refresh()
}

function rotateRight() {
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	updateAllAudios()	
	refresh()
}

function doubleUp() {
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	updateAllAudios()	
	refresh()
}

function doubleDown() {
	noteState.push(noteState[0])
	noteState.push(noteState[1])
	noteState.splice(0, 2)
	updateAllAudios()	
	refresh()
}

function flip() {
	noteState = noteState.reverse()
	updateAllAudios()	
	refresh()
}

let chordProgression = document.getElementById("chordProgression")
function nextChord() {
	let customChords = parseChords(chordProgression.value)
	if (customChords.length == 0) {
		return
	}
	currentChord += 1
	if (currentChord >= customChords.length) {
		currentChord = 0
	}
	//ctx.fillText(Object.keys(chords)[currentChord], 10, 50);
	//ctx.fillText("hi", 400, 400)
	setChord(customChords[currentChord])
	refresh()
	updateAllAudios()
}

function parseChords(chordString) {
	let splitChords = chordString.split(" ")
	let result = []
	for (let i = 0; i < splitChords.length; i++) {
		try {
			result.push(parseChord(splitChords[i]))
		} catch { }
	}
	return result
}

function parseChord(chordName) {
	var root
	var chordType
	if (chordName.length == 0) {
		throw new Error()
	} else if (chordName.length == 1) {
		root = chordName[0]
		chordType = ""
	} else if (chordName[1] == "#" || chordName[1] == "b") {
		root = chordName.substring(0, 2)
		chordType = chordName.substring(2)
	} else {
		root = chordName.substring(0, 1)
		chordType = chordName.substring(1)
	}
	let rootIndex = noteNames.indexOf(root)
	let chordNotes = chords[chordType];
	return transposeChord(chords[chordType][0], rootIndex)
}

function transposeChord(chord, interval) {
	let transposedChord = []
	for (let i = 0; i < chord.length; i++) {
		transposedChord.push((chord[i] + interval) % TET)
	}
	return transposedChord	
	
}

function setChord(chord) {
	console.log(chord)
	for (i = 0; i < TET; i++) {
		noteState[i] = chord.includes(i) ? 1 : 0
	}
}

refresh(true)

</script>
</body>
</html>