<!-- Musical Circles -->
<!DOCTYPE html>
<html>
<head>
	<title>Chordwheel</title>
	<link rel="icon" href='favicon.ico'>
	<style>
		body { background-color: hsl(0, 0%, 0%); }

	</style>
</head>
<body>
	<div id="main" >
		<canvas id="canvas" width="800px" height="800px" style="margin: auto; display: block;" ></canvas>
	</div>
<script>

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const DOT_SIZE = 23
const RADIUS = 175
const CENTER = [400, 400]

const SPACE_CODE = 32
const TET = 12
const notes = ['A', 'Bflat', 'B', 'C', "Csharp", 'D', 'Eflat','E', 'F', "Fsharp", 'G', 'Aflat']
const displayNotes = ['A', 'B♭', 'B', 'C', 'C♯', 'D', 'E♭','E', 'F', 'F♯', 'G', 'A♭']

let clickable = true
let currentChord = 0;

// organize into meaningful 'progression', can change root
const chords = {
	"Minor":			[0, 3, 7],			// Minor		// 
	'Suspended':		[0, 5, 7],		// Suspended		
	'Major':			[0, 4, 7], 		// Major			// Stunted
	//'Flat Five':		[0, 4, 6],		// Flat Five		// Stunted
	'Diminished':		[0, 3, 6],		// Diminished		// 
	'Augmented+':		[0, 4, 8],		// Augmented		// 
	// 4 note
	'Dominant Seventh':		[0, 4, 7, 10],	// Dominant Seventh		// 
	'Minor Seventh':		[0, 3, 7, 10],	// Minor Seventh		// Relaxed
	'Major Seventh':		[0, 4, 7, 11],	// Major Seventh
	'Minor Sixth':			[0, 3, 7, 9],	// Minor Sixth			// 
	'Suspended Seventh':	[0, 5, 7, 9],	// 				
	'Diminished Seventh': 	[0, 3, 6, 9],	// Diminished Seventh	
	'Minor Major Seventh':	[0, 3, 7, 11], 	// Minor Major Seventh
	'Mu':					[0, 2, 4, 7]	// Mu
}

// Extruded Contorted Embellished Elevated 
// Disfigured
// Embodied
// Reflected



let intervalColors = [
	'red',
	'blue',
	'purple',
	'green',
	'orange',	//minor 2nd
	'yellow',	// tritone
]

intervalColors2 = [
	`hsl(0,  100%, 50%)`, // orange
	`hsl(25, 100%, 50%)`, // orange
	`hsl(40, 100%, 50%)`, // orange-yellow
	`hsl(50, 100%, 50%)`, // yellow
	`hsl(60, 100%, 75%)`, // light yellow
	"white"
]

let noteColors = [
	`hsl(0, 100%, 50%)`, // red
	`hsl(25, 100%, 50%)`, // orange-red
	`hsl(45, 100%, 50%)`, // orange-yellow
	`hsl(60, 100%, 50%)`, // yellow
	`hsl(90, 100%, 50%)`, // yellow-green
	`hsl(130, 100%, 35%)`, // green
	`hsl(165, 100%, 35%)`, // green-blue
	`hsl(205, 100%, 40%)`, // blue-green
	`hsl(240, 100%, 50%)`, // blue
	`hsl(260, 100%, 50%)`, // blue-purple
	`hsl(280, 100%, 50%)`, // purple
	`hsl(320, 100%, 50%)`, // purple-red
]

let audios = []
let noteState = []
let clickAudio = new Audio()
clickAudio.src = "click.wav"
clickAudio.volume = .15

for (let i = 0; i < TET; i++) {
	let audio = new Audio()
	audio.loop = true
	audio.volume = .3
	audio.src = "notes/" + notes[i] + ".mp3"
	audios.push(audio)
	noteState[i] = false
}


/////////////////////
// CONTROL
/////////////////////
document.body.onkeyup = function(e) {
	if (e.keyCode == SPACE_CODE) {
    	nextChord()
    } else if (e.keyCode == 37) {
		rotateLeft()
	} else if (e.keyCode == 39) {
		rotateRight()
	} else if (e.keyCode == 38) {
		console.log("ok")
		doubleUp()
	} else if (e.keyCode == 40) {
		doubleDown()
	}
}


canvas.addEventListener('mousedown', function(e) {
    buttonClick(canvas, e)
})

function buttonClick(canvas, event) {
    const rect = canvas.getBoundingClientRect()
	let note = checkClick([event.clientX - rect.left, event.clientY - rect.top])
    if (note != -1) {
		noteState[note] = !noteState[note]
		updateAudio(audios[note], noteState[note])
		refresh()
	}
}

function checkClick(point) {
	if (!clickable) {
		return -1
	}
	for (let i = 0; i < TET; i++) {
		if (distanceToPoint(point, getPointOnCircle(CENTER, i, RADIUS)) < DOT_SIZE) {
			return i
		}
	}
	return -1
}

function distanceToPoint(p1, p2) {
	let dx = p1[0] - p2[0];
	let dy = p1[1] - p2[1];
	return Math.sqrt(dx * dx + dy * dy);
}

//////////// Sound
function updateAllAudios() {
	for (let i = 0; i < TET; i++) {
		updateAudio(audios[i], noteState[i])
	}
}

function updateAudio(audio, isOn) {
	if (isOn != audio.paused) {
		return // no change needed
	}
	if (isOn) {
		audio.currenttime = 0;
		audio.play()
	} else {
		audio.pause()
		audio.currenttime = 0;
		// clickable = false
		// var id = setInterval(
		// 	function() {
		// 		if (audio.volume == 0) {
		// 			audio.pause()
		// 			audio.currenttime = 0;
		// 			audio.volume = .3;
		// 			clearInterval(id);
		// 			clickable = true
		// 		} else if (audio.volume <= 0.01) {
		// 			audio.volume = 0
		// 		} else {
		// 			audio.volume -= 0.01;
		// 		}
		// 	}, 15
		// )
	}
}

function refresh(first = false) {
	if (!first) {
		clickAudio.currentTime = 0
		clickAudio.play()
	}
	ctx.clearRect(0, 0, 1000, 1000);
	drawChord()
	drawColorWheel()
}

function drawColorWheel() {
	for (i = 0; i < TET; i++) {
		let color = (360 * i) / TET
		drawDot(
			getPointOnCircle(CENTER, i, RADIUS), 
			noteToColor(i, true),
			displayNotes[i], 
			noteState[i] == 1); //notes[(i+117) % notes.length]
	}
}

function noteToColor(i, max, trueColor = false) {
	if (trueColor) {
		let color = 360 * i / TET
		return `hsl(${color}, 100%, 50%)`
	} else {
		return noteColors[i]
	}
}

function drawDot(center, color, text, filled) {
	ctx.lineWidth = 2
	ctx.beginPath()
	ctx.arc(center[0], center[1], DOT_SIZE, 0, 2 * Math.PI)
	if (filled) {
		ctx.fillStyle = color
		ctx.fill()
	} else {
		ctx.strokeStyle = color
		ctx.stroke()
	}
	//ctx.fillStyle = `black`
	//ctx.fillText(text, center[0]-8, center[1]+8)
}

function drawChord() {
	let chord = []
	for (let i = 0; i < TET; i++) {
		if (noteState[i]) {
			chord.push(i)
		}
	}
	let numIntervals = 0
	let intervalTotal = 0
	for (i = 0; i < chord.length; i++) {
		let n1 = chord[i]
		p1 = getPointOnCircle(CENTER, n1, RADIUS)
		for (let j = i + 1; j < chord.length; j++) {
			let n2 = chord[j]
			let p2 = getPointOnCircle(CENTER, n2, RADIUS)
			let interval = Math.min(
					Math.abs(n1 - n2),
					12 - Math.abs(n1 - n2)) % 6
			intervalTotal += interval
			numIntervals++
			// intervals are measured from dissonant (0, tritone) to consonant (5, fifth)
			drawLine(p1, p2, interval)
		}
	}
	if (numIntervals > 0) {
		//let consonanceScore = 100.0 * (intervalTotal / (5 * numIntervals))
		//console.log(consonanceScore + "%")
	}
}

function drawLine(pos1, pos2, interval) {
	ctx.lineWidth = 3
	if (interval == 5 || interval == 0) {
		ctx.lineWidth = 3
	}
	// TODO: white -> yellow -> red?
	//ctx.strokeStyle = `hsl(0, 100%, ${50 + interval * 10}%)` // white -> red
	//ctx.strokeStyle = `hsl(${interval * (60 / 5)}, 100%, 50%)` // yellow -> red
	ctx.strokeStyle = intervalColors2[interval]
	//ctx.strokeStyle = "white"
	ctx.beginPath()
	ctx.moveTo(pos1[0], pos1[1])
	ctx.lineTo(pos2[0], pos2[1])
	ctx.stroke()
}

function nextChord() {
	ctx.fillStyle = "white"
	ctx.font = "20px Arial";
	//ctx.fillText(Object.keys(chords)[currentChord], 10, 50);
	ctx.fillText("hi", 400, 400)
	
	chord = Object.values(chords)[currentChord]
	setChord(chord)
	refresh()
	updateAllAudios()
	currentChord = (currentChord + 1) % 13
}

function setChord(chord) {
	for (i = 0; i < TET; i++) {
		noteState[i] = 0
	}
	for (i = 0; i < chord.length; i++) {
		noteState[chord[i]] = 1
	}
}

function getPointOnCircle(center, n, radius) {
	n = n + 3
	return [center[0] + Math.cos(2 * Math.PI * n / TET) * radius, 
		center[1] + Math.sin(2 * Math.PI * n / TET) * radius]
}


function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	}
}

function rotateLeft() {
	noteState.push(noteState[0])
	noteState.splice(0, 1)
	updateAllAudios()
	refresh()
}

function rotateRight() {
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	updateAllAudios()	
	refresh()
}

function doubleUp() {
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	noteState.splice(0, 0, noteState[noteState.length - 1])
	noteState.pop()
	updateAllAudios()	
	refresh()
}

function doubleDown() {
	noteState.push(noteState[0])
	noteState.push(noteState[1])
	noteState.splice(0, 2)
	updateAllAudios()	
	refresh()
}

function flip() {
	noteState = noteState.reverse()
	updateAllAudios()	
	refresh()
}

refresh(true)

</script>
</body>
</html>